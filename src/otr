#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
from os.path import join, isdir, exists
import re
import subprocess
import time

try:
    from gtk import events_pending, main_iteration
    from gtk import gdk
    import gobject
    if os.name == "posix":
        gdk.threads_init()    
except:
    print "PyGTK/GTK is missing."
    sys.exit(-1)


if exists(join(sys.path[0], 'otrpath.py')):    
    f = open(join(sys.path[0], 'conf'), 'a')
    f.close()
else:
    sys.path.insert(0, "/usr/share/otr-verwaltung")
    

# intern
from gui.gui import Gui
from actions import actions
from configparser import Config
import fileoperations
import cutlists as cutlists_management
from constants import Section, Action
from planning import Planning
import otrpath

class App:
    
    def __init__(self):             
        # read configs
        if exists(otrpath.get_path('conf')):
            self.config = Config(otrpath.get_path('conf'))
        else:
            self.config = Config(otrpath.get_config_path('conf'))

        self.__search_text = ""
        self.locked = False
            
        # regex
        self.__uncut_video = re.compile('.*_([0-9]{2}\.){2}([0-9]){2}_([0-9]){2}-([0-9]){2}_.*_([0-9])*_TVOON_DE.mpg\.(avi|HQ\.avi|mp4)$')
        self.__cut_video = re.compile('.*(avi|mp4)$') 
    
        self.section = Section.OTRKEY
    
        # load gui
        self.__gui = Gui(self)
    
        # show undecoded otrkeys         
        self.show_section(Section.OTRKEY)
        
        self.planned_broadcasts = Planning()
        self.planned_broadcasts.read_config(self.config.get('planning', 'planned_items'))
        
        self.__gui.main_window.broadcasts_badge()                         
        self.__gui.main_window.update_details()                         
                                
    ### 
    ### Show sections
    ###
    
    def show_section(self, section):
        """ Shows one of the five different sections. 
            - set files of treeview
            - set section-variable to current section
            - set appropriate toolbar"""

        # set current section
        self.section = section
        
        # set toolbar
        self.__gui.main_window.set_toolbar(section)
                
        self.__gui.main_window.clear_files()
        files = []
        text = ""
        
        if section == Section.PLANNING:
            text = self.section_planning()
            
            self.__gui.main_window.get_widget('table_details').hide()            
            self.__gui.main_window.show_planning(True)
        else:
            self.__gui.main_window.show_planning(False)
            
            if self.config.get('common', 'show_details'):
                self.__gui.main_window.get_widget('table_details').show()
        
        if section == Section.OTRKEY:
            text, files = self.section_otrkey()
        
        elif section == Section.AVI_UNCUT:
            text, files = self.section_avi_uncut()   

        elif section == Section.AVI_CUT:
            text, files = self.section_avi_cut()   

        elif section == Section.TRASH:
            text, files = self.section_trash()   

        elif section == Section.ARCHIVE: 
            # returns NO files       
            text = self.section_archive()

        if len(files) > 0: # this is not executed when the section is "Archive"
            if len(files) == 1:
                text += " (1 Datei)"
            else:
                text += " (%s Dateien) " % len(files)
            
            files.sort() 
            
            # put filenames into treestore
            for f in files:
                # TODO: don't show files if in use
                self.append_row_treeview_files(None, f)

        # set message text
        self.__gui.main_window.get_widget('labelMessage').set_text(text)


    # helper for different sections
    def section_planning(self):
        text = "Diese Aufnahmen wurden geplant." 
       
        for count, broadcast in enumerate(self.planned_broadcasts):
            if self.search(broadcast.title):
                self.__gui.main_window.append_row_planning(count)
            
        return text
             
    def section_otrkey(self):
        text = "Diese Dateien wurden noch nicht dekodiert." 
        path = self.config.get('folders', 'new_otrkeys')
        
        if path == "":      
            return text, []
        
        files = [join(path, f) for f in os.listdir(path) if f.endswith(".otrkey") and self.search(f)]                           
            
        return (text, files)
         
    def section_avi_uncut(self):
        text = "Diese Dateien wurden noch nicht geschnitten."
        path = self.config.get('folders', 'uncut_avis')
        
        files = [join(path, f) for f in os.listdir(path) if self.__uncut_video.match(f) and self.search(f)]
            
        return (text, files)
        
    def section_avi_cut(self):
        text = "Diese avi-Dateien sind fertig geschnitten."
        if self.config.get('common', 'use_archive'):
            text += " Sie können ins Archiv verschoben werden."
                
        path = self.config.get('folders', 'cut_avis')
        
        files = []                
        for f in os.listdir(path):
            if not self.__uncut_video.match(f):
                if self.__cut_video.match(f):
                    if self.search(f):
                        files += [join(path, f)]
        
        return (text, files)
        
    def section_trash(self):
        text = "Diese otrkey- und avi-Dateien wurden bereits dekodiert bzw. geschnitten. Sie können normalerweise gelöscht werden."
        path = self.config.get('folders', 'trash')
                    
        files = [join(path, f) for f in os.listdir(path) if (f.endswith('.otrkey') or f.endswith('.avi')) and self.search(f)]
                
        return (text, files)

    def section_archive(self):
        text = "Diese Dateien wurden ins Archiv verschoben."

        path = self.config.get('folders', 'archive')
        
        self.tree(None, path)        
        
        return text            
                 
    # recursive function for archive to add folders and files with a tree structure
    def tree(self, parent=None, path=None):              
        if parent != None:            
            dir = self.__gui.main_window.get_widget('treeview_files').get_model().get_value(parent, 0)
        else:  # base path (archive directory)
            dir = path

        files = []
        files = os.listdir(dir)            

        for file in files:
            full_path = join(dir, file)
            
            if isdir(full_path):                
                iter = self.append_row_treeview_files(parent, full_path)
                self.tree(iter)
            else:
                if file.endswith('.avi'):
                    if self.search(file):
                        self.append_row_treeview_files(parent, full_path)

    ###
    ### Helpers
    ###
    
    def rename_by_schema(self, filename, schema=""):   
        if schema == "":
            schema = self.config.get('rename', 'schema')        
        
        if self.__uncut_video.match(filename):           
            
            parts = filename.split('_')
            parts.reverse()

            titel_list = parts[6:len(parts)]
            titel_list.reverse()
            titel = " ".join(titel_list)
            titel_mit = "_".join(titel_list)

            stunde, minute = parts[4].split('-')
            jahr, monat, tag = parts[5].split('.')           
            monatsname = time.strptime(monat, '%m')
            monatsname = time.strftime('%B', monatsname)

            sender_gross = parts[3].capitalize()

            format = parts[0]
            mp4 = False
            
            if 'HQ' in format:
                format = 'HQ'                
            elif 'mp4' in format:
                format = 'mp4'
                mp4 = True
            else:
                format = 'avi'

            values = {
                'titel' : titel,
                'titel_' : titel_mit,
                'sender' : parts[3],
                'SENDER': sender_gross,
                'tag': tag,
                'monat': monat,
                'MONAT': monatsname,
                'jahr': jahr,
                'stunde': stunde,
                'minute': minute,
                'dauer' : parts[2],
                'format' : format
            }
             
            for token, value in values.iteritems():
                schema = schema.replace('{%s}' % token, value)
                 
            if mp4 == True:
                schema += ".mp4"
            else:
                schema += ".avi"                   
                
            return schema
        else:         
            return filename
     
    def append_row_treeview_files(self, parent, filename):        
        iter = self.__gui.main_window.append_row_files(parent, filename, fileoperations.get_size(filename), fileoperations.get_date(filename))
        return iter
     
    
    ### 
    ### Search
    ### 
                      
    def start_search(self, search):
        self.__search_text = search.lower()

        items = []        
        # create dict of counts
        counts = {}

        for method, section in [(self.section_otrkey, Section.OTRKEY),
                                (self.section_avi_uncut, Section.AVI_UNCUT),
                                (self.section_avi_cut, Section.AVI_CUT),
                                (self.section_trash, Section.TRASH)]:
            files = []
            text, items = method()   
            count = len(items)
            if count > 0:
                counts[section] = "(%s)" % count
            else:
                counts[section] = ""
         
        # archive 
        files = []       
        for root, dirs, wfiles in os.walk(self.config.get('folders', 'archive')):
            for f in wfiles:
                # TODO: match all videos files mp4, usw.
                if f.endswith('.avi') and self.search(f):
                    files += [join(root, f)]

        count = len(files)
        if count > 0:
            counts[Section.ARCHIVE] = "(%s)" % count
        else:
            counts[Section.ARCHIVE] = ""

        # planning
        items = []
        for count, broadcast in enumerate(self.planned_broadcasts):
            if self.search(broadcast.title):
                items += [count]

        count = len(items)
        if count > 0:
            counts[Section.PLANNING] = "(%s)" % count
        else:
            counts[Section.PLANNING] = ""
        
        self.show_section(self.section)                   
        return counts
    
    def stop_search(self):
        self.__search_text = ""
        self.show_section(self.section)
        
    def search(self, f):
        if self.__search_text == "":
            return True
        else:    
            if self.__search_text in f.lower():
                return True
            else:
                return False
        
    ###
    ### Actions
    ###        
    
    def perform_action(self, chosen_action, filenames=None, broadcasts=None, cut_action=None):
        """ Performs an action (toolbar, context menu, etc.) """

        if broadcasts != None and chosen_action in [Action.PLAN_EDIT, Action.PLAN_SEARCH, Action.PLAN_REMOVE, Action.PLAN_ADD]:
            if len(broadcasts) == 0 and chosen_action != Action.PLAN_ADD:
                if len(self.__gui.main_window.get_widget('treeview_planning').get_model()) > 0:
                    if self.__gui.question_box("Es ist keine Sendung markiert! Sollen alle Sendungen verarbeitet werden?"):
                        broadcasts = []                    

                        def foreach(model, path, iter, broadcasts):
                            broadcasts += [iter]

                        self.__gui.main_window.get_widget('treeview_planning').get_model().foreach(foreach, broadcasts)
                    else:
                        return
                else:
                    return

        elif filenames != None:
            if len(filenames) == 0 and chosen_action != Action.NEW_FOLDER:
                if len(self.__gui.main_window.get_widget('treeview_files').get_model()) > 0:
                    if self.__gui.question_box("Es ist keine Datei markiert! Sollen alle Dateien verarbeitet werden?"):
                        filenames = [row[0] for row in self.__gui.main_window.get_widget('treeview_files').get_model()]
                    else:
                        return
                else:
                    return
           
        action = actions.get_action(chosen_action, self.__gui)            
         
        self.locked = True
               
        # different actions:
        if chosen_action in [Action.DECODE, Action.CUT, Action.DECODEANDCUT]:             
            action.do(chosen_action, filenames, self.config, self.rename_by_schema, cut_action)
    
        elif chosen_action == Action.RENAME: 
            action.do(filenames)
    
        elif chosen_action == Action.REAL_DELETE: 
            action.do(filenames)
    
        elif chosen_action == Action.RESTORE: 
            action.do(filenames, self.config.get('folders', 'new_otrkeys'), self.config.get('folders', 'uncut_avis'), self.config.get('folders', 'cut_avis'))
    
        elif chosen_action == Action.DELETE:
            action.do(filenames, self.config.get('folders', 'trash'))
    
        elif chosen_action == Action.PLAY: 
            action.do(filenames[0], self.config.get('play', 'player'))
    
        elif chosen_action == Action.CUT_PLAY: 
            action.do(filenames[0], self.config.get('play', 'mplayer'), self.config.get('folders', 'uncut_avis'), self.config.get('cut', 'server'), self.config.get('cut', 'choose_cutlists_by'), self.config.get('cut', 'delete_cutlists'))            
    
        elif chosen_action == Action.PLAN_REMOVE: 
            action.do(broadcasts, self.planned_broadcasts) 
    
        elif chosen_action == Action.PLAN_SEARCH: 
            action.do(broadcasts, self.planned_broadcasts)            
    
        elif chosen_action == Action.PLAN_ADD: 
            action.do(self.planned_broadcasts)
    
        elif chosen_action == Action.PLAN_EDIT: 
            action.do(broadcasts[0], self.planned_broadcasts)       
            
        elif chosen_action == Action.PLAN_RSS:
            action.do(self.planned_broadcasts) 
    
        elif chosen_action == Action.ARCHIVE: 
            action.do(filenames, self.config.get('folders', 'archive'))
     
        elif chosen_action == Action.NEW_FOLDER:
            if len(filenames) == 0:
                action.do(self.config.get('folders', 'archive'))
            else:
                action.do(filenames[0])
        
        self.locked = False
        
        # update view?
        if action.update_list:            
            self.__gui.main_window.do_search(self.__search_text)
            self.show_section(self.section)
            
    
    def __show(self, cuts, avi_filename, edl_subtitles_cb):        
        f_edl = open(join(self.config.get('folders', 'new_otrkeys'), ".tmp.edl"), "w")
        f_sub = open(join(self.config.get('folders', 'new_otrkeys'), ".tmp.sub"), "w")    
        
        edl_subtitles_cb(f_edl, f_sub, cuts)        
        
        f_edl.close()
        f_sub.close()
        
        f_edl = join(self.config.get('folders', 'new_otrkeys'), ".tmp.edl")
        f_sub = join(self.config.get('folders', 'new_otrkeys'), ".tmp.sub")
            
        p = subprocess.Popen([self.config.get('play', 'mplayer'), "-osdlevel", "3", "-edl", f_edl, "-sub", f_sub, avi_filename])
       
        # wait
        while p.poll() == None:
            while events_pending():
                main_iteration(False)
                
        fileoperations.remove_file(f_edl)
        fileoperations.remove_file(f_sub)
        
    def show_cuts(self, avi_filename, cutlist):       
        
        def edl_subtitles_cb(f_edl, f_sub, cuts):            
            diff = 10
            
            sub_count = 0

            f_edl.write("0 ")      

            for count, start, duration in cuts:
                end = start + duration

                f_edl.write("%s 0\n" % (start - diff))
                f_edl.write("%s %s 0\n" % (start + diff, end - diff))
                f_edl.write("%s " % (end + diff))

                for second in range(diff):
                    sub_count += 1
                    f_sub.write("%s\n" % sub_count)
                    f_sub.write("%s --> %s\n" % (self.format_seconds(start-diff+second), self.format_seconds(start-diff+second+1)))
                    f_sub.write("Zum Schnitt noch %s Sekunden...\n\n" % str(diff - second))            
                    
                for second in range(diff):
                    sub_count += 1
                    f_sub.write("%s\n" % sub_count)
                    f_sub.write("%s --> %s\n" % (self.format_seconds(end-diff+second), self.format_seconds(end-diff+second+1)))
                    f_sub.write("Zum Schnitt noch %s Sekunden...\n\n" % str(diff - second))
                
            f_edl.write("50000 0")
         
         
        error = cutlist.read_cuts()
                
        if error:
            self.__gui.message_error_box(error)
            return           

        self.__show(cutlist.cuts, avi_filename, edl_subtitles_cb)            
    
    def show_cuts_after_cut(self, avi_filename, cutlist):
        
        def edl_subtitles_cb(f_edl, f_sub, cuts):                    
            diff = 10
            
            length = 0
            sub_count = 0
                            
            for count, start, duration in cuts:
                f_edl.write("%s %s 0\n" % (diff + length, length + duration - diff))
                length += duration
                
                # vor dem schnitt:
                for second in range(diff):
                    sub_count += 1
                    f_sub.write("%s\n" % sub_count)
                    f_sub.write("%s --> %s\n" % (self.format_seconds(length - diff + second), self.format_seconds(length - diff + second + 1)))
                    f_sub.write("Zum Schnitt noch %s Sekunden...\n\n" % str(diff - second))                      


        error = cutlist.read_cuts()
                
        if error:
            self.__gui.message_error_box(error)
            return           

        self.__show(cutlist.cuts, avi_filename, edl_subtitles_cb)
    
    def format_seconds(self, seconds):
        hrs = seconds / 3600       
        leftover = seconds % 3600
        mins = leftover / 60
        secs = leftover % 60
        ms = int(seconds) - seconds
        
        return "%02d:%02d:%02d,%03d" % (hrs, mins, secs, ms)
                      
    def run(self):
        self.__gui.main_window.show()      

        if self.config.get('folders', 'new_otrkeys') == "":      
            self.__gui.message_info_box("Dies ist offenbar das erste Mal, dass OTR-Verwaltung gestartet wird.\n\nEs müssen zunächst einige wichtige Einstellungen vorgenommen werden. Klicken Sie dazu auf OK.")
            self.__gui.preferences_window.show()
               
        self.__gui.run()
        
        # write planning to config
        self.config.set('planning', 'planned_items', self.planned_broadcasts.get_config())               

             
app = App()
app.run()
app.config.save()
